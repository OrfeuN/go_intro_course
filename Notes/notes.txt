Strongly typed
    string, floar, int, byte, struct

Structures
    Structs, pointers, methods, interfaces

Error handling
    Errors are handled like values - capture those values and handle it in an explicit manner
    In a functio , start with the "sad" paths, handle the different (error) paths and finally handle the "happy" situation

Multi-threaded
    concurrency, goroutines, sync package

Opinionated language for syntax and style

----------------

In a directory, there can only be one func main()

Go programmes are organised into packages:
    a collection of source files in a directory that are compiled together.
    within the same package, functions, types, variables, and constants defined in one source file are visible to all other source files.

    every go file needs a package name
    every go programme needs a package named "main" & a main functon
    only one main func in a given package (?)

---

Control:
    No do while loop in go
    1) for init; condition; increment {}
    2) for condition{}
    3) for {}

    for i:=0; i < 100; i++{

    }

    var i int = 0
    for i < 10{
        //
        i++;
    }

    use range
    for index, item := range oldMap{
    }

    // Reverse a
    for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
        a[i], a[j] = a[j], a[i]
    }
    can use _ to discard; without discarding, we'll get an error saying "index" isnt being used
        sentence := "this is a sentence"

        for _, letter:= range sentence{
            fmt.Print(string(letter))
        }

    switch. use fallthrough to keep going if a condition is methods
        var i int = 9

        switch {
            case i != 10:
                fmt.Println("Does not equal 10")
                fallthrough
            case i < 10: fmt.Println("Less than 10")
            case i > 10: fmt.Println("Greater than 10")
            default: fmt.Println("Is 10")
        }

---------
functions
    func printAge(age int) int{
        return age + 10
    }
    func printNumber() (age int, justanum int){
        justanum = 20
        age = 10
        // return 10, justanum
        return
    }
    num1, num2 := printNumber()

    a function can be variadic
    func anotherNum(ages ...int) int{
        return 1
    }
    anotherNum(3, 5, 6)

Array
    var items [5]int
    var items [5]int = [5]int{1,2,3,4,5}
    items := [5]int{1,2,3,4,5}
    items := [...]int{1,2,3,4,5}

    make and slice gets a pointer to underlying array
        var mySlice []int = make([]int, 5, 10) //size of 5 with a capacity /maxSize of 10
        // len(mySlice) --> 5
        // cap(mySlice) --> 10

        fruitArray := [5]strin{"banana", "apple","grapes", "mango", "blueberry"}
        splicedFruit := fruitArray[1..3] // apple & grapes // len of 2 & cap of 4
        fruits := append(splicedFruit, "blackberry", "cherry") // apple, grape, blackberry, cherry  // len of 4 & cap of 4

Map
    // key of int and holds string
        emails := map[int]string{4: "Four", 1: "One"}
        var emails map[int]string = make(map[int]string)
        
        emails[5] = "another"
        emails[10] = "Twenty"
        emails[76] = "five"

        firstEmail, ok := emails[0] // ok will be false and firstEmail is nnil

        if email, ok := emails[0]; ok{} //executes code if there is a key of 0 in the map

        delete(emails, 5) // deletes the item for a key of 5