Strongly typed
    string, floar, int, byte, struct

Structures
    Structs, pointers, methods, interfaces

Error handling
    Errors are handled like values - capture those values and handle it in an explicit manner
    In a functio , start with the "sad" paths, handle the different (error) paths and finally handle the "happy" situation

Multi-threaded
    concurrency, goroutines, sync package

Opinionated language for syntax and style

----------------

In a directory, there can only be one func main()

Go programmes are organised into packages:
    a collection of source files in a directory that are compiled together.
    within the same package, functions, types, variables, and constants defined in one source file are visible to all other source files.

    every go file needs a package name
    every go programme needs a package named "main" & a main functon
    only one main func in a given package (?)

---

Control:
    No do while loop in go
    1) for init; condition; increment {}
    2) for condition{}
    3) for {}

    for i:=0; i < 100; i++{

    }

    var i int = 0
    for i < 10{
        //
        i++;
    }

    use range
    for index, item := range oldMap{
    }

    // Reverse a
    for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
        a[i], a[j] = a[j], a[i]
    }
    can use _ to discard; without discarding, we'll get an error saying "index" isnt being used
        sentence := "this is a sentence"

        for _, letter:= range sentence{
            fmt.Print(string(letter))
        }

    switch. use fallthrough to keep going if a condition is methods
        var i int = 9

        switch {
            case i != 10:
                fmt.Println("Does not equal 10")
                fallthrough
            case i < 10: fmt.Println("Less than 10")
            case i > 10: fmt.Println("Greater than 10")
            default: fmt.Println("Is 10")
        }

---------
functions
    func printAge(age int) int{
        return age + 10
    }
    func printNumber() (age int, justanum int){
        justanum = 20
        age = 10
        // return 10, justanum
        return
    }
    num1, num2 := printNumber()

    a function can be variadic
    func anotherNum(ages ...int) int{
        return 1
    }
    anotherNum(3, 5, 6)

Array
    var items [5]int
    var items [5]int = [5]int{1,2,3,4,5}
    items := [5]int{1,2,3,4,5}
    items := [...]int{1,2,3,4,5}

    make and slice gets a pointer to underlying array
        var mySlice []int = make([]int, 5, 10) //size of 5 with a capacity /maxSize of 10
        // len(mySlice) --> 5
        // cap(mySlice) --> 10

        fruitArray := [5]string{"banana", "apple","grapes", "mango", "blueberry"}
        splicedFruit := fruitArray[1..3] // apple & grapes // len of 2 & cap of 4
        fruits := append(splicedFruit, "blackberry", "cherry") // apple, grape, blackberry, cherry  // len of 4 & cap of 4

Map
    // key of int and holds string
        emails := map[int]string{4: "Four", 1: "One"}
        var emails map[int]string = make(map[int]string)
        
        emails[5] = "another"
        emails[10] = "Twenty"
        emails[76] = "five"

        firstEmail, ok := emails[0] // ok will be false and firstEmail is nnil

        if email, ok := emails[0]; ok{} //executes code if there is a key of 0 in the map

        delete(emails, 5) // deletes the item for a key of 5


Structs 
    // a comment has to be provided for exportable types
    type User struct{
            ID      int
            name   string
            email   string
    }
    //capitalised means it will be accessible outside of the package
    user := User{ID:1, name: "name", email:"email"}

    type User struct{
            ID              int
            name, email   string
    }

    // a comment has to be provided for exportable types
    type Group struct{
        role        string
        users       []User
    }

defer delays exexuction of line and acts as a first in last out (reversed order)
    panic ends the programme
    recover tells go what to do if panic occurs
        returns what was passed to panic
    recover must be paired with defer. which will fire even after panic 


methods
    func (u User) describe() string {
        desc := fmt.Sprintf("Name: %s %s, Id: %d, Email: %s", u.FName, u.LName, u.ID, u.Email)
        return desc
    }

    OR 

    Use pointer if state is to be modified
    func (u *User) describe() string {
        desc := fmt.Sprintf("Name: %s %s, Id: %d, Email: %s", u.FName, u.LName, u.ID, u.Email)
        return desc
    }

    usage: 
        user:= User {ID: 1}
        user.describe()

interfaces:
    set of behaviours that define a type

    type name interface{
        ....
    }

go handles routes using net/http
    func main(){
        http.HandleFunc("/", home) // home is a function
    }